{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["interface AsyncPollOptions {\n  interval: number;\n  timeout: number;\n}\n\nimport { performance } from 'perf_hooks';\n\nasync function delay(t: number) {\n  /**\n   * NOTE:\n   *\n   * References for `process.nextTick` vs `setImmediate` vs `Promise`:-\n   *  1. https://bit.ly/2Mmk7Xa\n   *  2. https://bit.ly/2TIIPYr\n   */\n  return new Promise(yay => t < 1 ? process.nextTick(yay) : setTimeout(yay, t));\n}\n\nexport async function asyncPoll<T>(\n  fn: () => Promise<T>,\n  conditionFn: (d: T) => boolean,\n  options: AsyncPollOptions\n) {\n  const { interval, timeout }: AsyncPollOptions = options || {};\n\n  if (typeof interval !== 'number' || interval < 0) {\n    throw new TypeError(`Expected 'interval' to be a valid number, but received '${interval}'`);\n  }\n\n  if (typeof timeout !== 'number') {\n    throw new TypeError(`Expected 'timeout' to be a valid number, but received '${timeout}'`);\n  }\n\n  try {\n    const itv = +interval;\n    const maxItv = +timeout;\n    const isForever = timeout < 1;\n    let d: T;\n    let op = 0;\n    let ed = 0;\n    let duration = 0;\n    let i = 0;\n    let shouldContinuePolling = false;\n\n    performance.mark('poll starts');\n    do {\n      op = (performance.mark(`poll ${i} starts`), performance.now());\n      d = await fn();\n      ed = (performance.mark(`poll ${i} ends`), performance.now());\n\n      const diff = Math.ceil(ed - op);\n\n      shouldContinuePolling = isForever ? true : duration < maxItv && !conditionFn(d);\n      duration += diff > itv ? diff : itv;\n      performance.measure(`poll ${i} takes`, `poll ${i} starts`, `poll ${i} ends`);\n\n      /** NOTE: Fast return */\n      if (!shouldContinuePolling) break;\n\n      await delay(itv - diff);\n      performance.mark('next poll starts');\n      performance.measure(`poll ${i + 1} starts after`, `poll ${i} ends`, 'next poll starts');\n      i += 1;\n    } while (shouldContinuePolling);\n    performance.mark('poll ends');\n    performance.measure('poll spent', 'poll starts', 'poll ends');\n\n    return d;\n  } catch (e) {\n    throw e;\n  }\n}\n\nexport default asyncPoll;\n"],"names":["async","delay","t","Promise","yay","process","nextTick","setTimeout","asyncPoll","fn","conditionFn","options","interval","timeout","TypeError","itv","maxItv","isForever","d","op","ed","duration","i","shouldContinuePolling","performance","mark","now","diff","Math","ceil","measure","e"],"mappings":"yGAOAA,eAAeC,MAAMC,GAQnB,OAAO,IAAIC,QAAQC,GAAOF,EAAI,EAAIG,QAAQC,SAASF,GAAOG,WAAWH,EAAKF,IAG5EF,eAAsBQ,UACpBC,EACAC,EACAC,GAEA,MAAMC,SAAEA,EAAQC,QAAEA,GAA8BF,GAAW,GAE3D,GAAwB,iBAAbC,GAAyBA,EAAW,EAC7C,MAAM,IAAIE,qEAAqEF,MAGjF,GAAuB,iBAAZC,EACT,MAAM,IAAIC,oEAAoED,MAGhF,IACE,MAAME,GAAOH,EACPI,GAAUH,EACVI,EAAYJ,EAAU,EAC5B,IAAIK,EACAC,EAAK,EACLC,EAAK,EACLC,EAAW,EACXC,EAAI,EACJC,GAAwB,EAE5BC,uBAAYC,KAAK,eACjB,EAAG,CACKD,uBAAYC,aAAaH,YAA/BH,EAA4CK,uBAAYE,MACxDR,QAAUT,IACJe,uBAAYC,aAAaH,UAA/BF,EAA0CI,uBAAYE,MAEtD,MAAMC,EAAOC,KAAKC,KAAKT,EAAKD,GAO5B,GALAI,IAAwBN,GAAmBI,EAAWL,IAAWN,EAAYQ,GAC7EG,GAAYM,EAAOZ,EAAMY,EAAOZ,EAChCS,uBAAYM,gBAAgBR,kBAAmBA,mBAAoBA,WAG9DC,EAAuB,YAEtBtB,MAAMc,EAAMY,GAClBH,uBAAYC,KAAK,oBACjBD,uBAAYM,gBAAgBR,EAAI,yBAA0BA,SAAU,oBACpEA,GAAK,QACEC,GAIT,OAHAC,uBAAYC,KAAK,aACjBD,uBAAYM,QAAQ,aAAc,cAAe,aAE1CZ,EACP,MAAOa,GACP,MAAMA"}
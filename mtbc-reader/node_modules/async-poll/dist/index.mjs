import{performance as e}from"perf_hooks";async function t(e){return new Promise(t=>e<1?process.nextTick(t):setTimeout(t,e))}async function r(r,o,l){const{interval:s,timeout:a}=l||{};if("number"!=typeof s||s<0)throw new TypeError(`Expected 'interval' to be a valid number, but received '${s}'`);if("number"!=typeof a)throw new TypeError(`Expected 'timeout' to be a valid number, but received '${a}'`);try{const l=+s,n=+a,p=a<1;let i,m=0,u=0,c=0,d=0,f=!1;e.mark("poll starts");do{e.mark(`poll ${d} starts`),m=e.now(),i=await r(),e.mark(`poll ${d} ends`),u=e.now();const s=Math.ceil(u-m);if(f=!!p||c<n&&!o(i),c+=s>l?s:l,e.measure(`poll ${d} takes`,`poll ${d} starts`,`poll ${d} ends`),!f)break;await t(l-s),e.mark("next poll starts"),e.measure(`poll ${d+1} starts after`,`poll ${d} ends`,"next poll starts"),d+=1}while(f);return e.mark("poll ends"),e.measure("poll spent","poll starts","poll ends"),i}catch(e){throw e}}export default r;export{r as asyncPoll};
//# sourceMappingURL=index.mjs.map
